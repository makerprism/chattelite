<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Server-sent events</title>
    <style>
        p {
            margin-top: 0.5em;
            margin-bottom: 0.5em;
        }

    </style>

    <script src="/chattelite-client.min.js"></script>

    <script>
        "use strict"; (() => {
            var f = i => decodeURIComponent(escape(i)), v = i => i.replace(/\r\n|\r/g, `
`), h = class extends EventTarget {
                    constructor(t, e) { super(); this.CONNECTING = 0; this.OPEN = 1; this.CLOSED = 2; this.withCredentials = !1; this.headers = {}; this.lastEventId = ""; this.reconnectionTime = 2e3; this.responseTextCursor = 0; this.eventTypeBuffer = ""; this.idBuffer = ""; this.dataBuffer = ""; this.canReconnect = !0; this.url = t, this.withCredentials = Boolean(e && e.withCredentials), e && e.headers && (this.headers = e.headers), this.addEventListener("error", s => { this.onerror && this.onerror(s) }), this.addEventListener("message", s => { this.onmessage && this.onmessage(s) }), this.addEventListener("open", s => { this.onopen && this.onopen(s) }), this.connect() } announceConnection() { this.readyState = this.OPEN, this.dispatchEvent(new Event("open")), this.responseTextCursor = 0 } connect(t = this.url) { this.readyState = this.CONNECTING; let e = this.xhr = new XMLHttpRequest; e.open("GET", t, !0); for (let s in this.headers) e.setRequestHeader(s, this.headers[s]); e.setRequestHeader("Accept", "text/event-stream"), e.setRequestHeader("Cache-Control", "no-cache"), this.lastEventId && e.setRequestHeader("Last-Event-ID", this.lastEventId), e.onreadystatechange = () => { if (!(e.readyState <= 1 || this.readyState === this.CLOSED)) { if (e.readyState === 4) { this.reestablishConnection(); return } switch (e.status) { case 200: this.handleConnection(e), this.interpretStream(e); break; case 204: this.canReconnect = !1; break; case 301: case 307: let s = e.getResponseHeader("Location"); this.failConnection(e, !0), s && this.connect(s); break; default: this.failConnection(e) } } }, e.send() } dispatchMessageEvent(t) {
                        if (this.lastEventId = this.idBuffer, this.dataBuffer === "") { this.eventTypeBuffer = ""; return } this.dataBuffer[this.dataBuffer.length - 1] === `
`&& (this.dataBuffer = this.dataBuffer.slice(0, -1)); let e = this.eventTypeBuffer || "message", s = new MessageEvent(e, { data: this.dataBuffer, origin: t, lastEventId: this.lastEventId }); this.eventTypeBuffer = "", this.dataBuffer = "", this.dispatchEvent(s)
                    } handleConnection(t) { if (this.readyState === this.CONNECTING) { let e = t.getResponseHeader("Content-Type"); e && e.toLowerCase() === "text/event-stream" ? this.announceConnection() : this.failConnection(t) } } failConnection(t, e = !1) { this.readyState = this.CLOSED, e || this.dispatchEvent(new Event("error")), this.canReconnect = !1, t.abort() } interpretStream(t) {
                        if (this.readyState !== this.OPEN) return; let e = ""; try { e = t.responseText } catch (r) { return } let s = e.substring(this.responseTextCursor); this.responseTextCursor = e.length; let d = v(f(s)).split(`
`); for (let r = 0; r < d.length; r++) { let n = d[r]; if (n === "") this.dispatchMessageEvent(t.responseURL); else { let a = n.indexOf(":"); if (a !== 0) if (a !== -1) { let l = n.substring(0, a), o = n.substring(a + 1), u = o.indexOf(" ") === 0 ? o.slice(1) : o; this.processField({ field: l, value: u }) } else this.processField({ field: n, value: "" }) } }
                    } processField(t) {
                        switch (t.field) {
                            case "event": this.eventTypeBuffer = t.value; break; case "data": this.dataBuffer += `${t.value}
`; break; case "id": t.value.indexOf("\0") === -1 && (this.idBuffer = t.value); break; case "retry": let e = +t.value; Number.isInteger(e) && (this.reconnectionTime = e)
                        }
                    } reestablishConnection() { this.readyState === this.CLOSED || !this.canReconnect || (this.readyState = this.CONNECTING, this.dispatchEvent(new Event("error")), setTimeout(() => { this.readyState === this.CONNECTING && this.connect() }, this.reconnectionTime)) } close() { this.readyState = this.CLOSED, this.xhr && this.xhr.abort() }
                }, c = h; window.EventSourceWithHeaders = c;
        })();
//# sourceMappingURL=index.js.map

    </script>
</head>

<body>
    <div id="root" style="max-height:90vh;overflow-y: auto;"></div>
    <script defer>
        ChatteliteClient.init("http://127.0.0.1:8000");

        let JWT;
        let CONVERSATION_ID;
        let event_source;
        let root = document.getElementById("root");


        async function connect_to_conversation() {
            console.log("CONVERSATION_ID", CONVERSATION_ID);

            let previous_events = await ChatteliteClient.Endpoints.get_conversation_events({ session_token: JWT }, CONVERSATION_ID);
            console.log(previous_events);

            for (let e of previous_events.events) {
                let data = document.createElement("p");
                data.innerText = "old: " + JSON.stringify(e);
                root.appendChild(data);
                data.scrollIntoView();
            }

            event_source = new EventSourceWithHeaders("http://127.0.0.1:8000/conversation/" + CONVERSATION_ID + "/sse", { headers: { "X-Access-Token": JWT } });
            event_source.onmessage = (event) => {
                let data = document.createElement("p");
                let time = new Date().toLocaleTimeString();
                data.innerText = time + ": " + event.data;
                root.appendChild(data);
                data.scrollIntoView();
            }
        }

        async function start() {
            await fetch("/login").then(async r => {
                if (r.status != 200) throw "error"

                let data = await r.json();

                console.log("login", data);

                JWT = data.jwt;
                CONVERSATION_ID = data.conversation_id;

            }).then(connect_to_conversation);
        }

        start();

        function send(e) {
            ChatteliteClient.Endpoints.send_message({ session_token: JWT }, CONVERSATION_ID, {
                content: message
            });
            message = "";
            document.getElementById("message").value = "";
        }

        async function join(e) {
            fetch("/join", {
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                method: "POST",
                body: JSON.stringify({
                    conversation_id: CONVERSATION_ID
                })
            }
            ).then(_ => {
                connect_to_conversation();
            })
        }

        function leave(e) {
            fetch("/leave", {
                headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json'
                },
                method: "POST",
                body: JSON.stringify({
                    conversation_id: CONVERSATION_ID
                })
            })
            if (event_source) {
                event_source.close();
            }
            root.innerHTML = "";
        }

        let start_typing = null;
        let stop_typing = null;

        function input(e) {
            message = e.target.value;
            if (!start_typing) {
                ChatteliteClient.Endpoints.start_typing({ session_token: JWT }, CONVERSATION_ID);
                start_typing = setTimeout(_ => start_typing = null, 2000);
            }
            if (stop_typing) clearTimeout(stop_typing);
            stop_typing = setTimeout(_ => {
                ChatteliteClient.Endpoints.stop_typing({ session_token: JWT }, CONVERSATION_ID);
            }, 1000);
        }

        let message = "";
    </script>

    <input type="text" id="message" oninput="input(event)">
    <button onclick="send(event)">send</button>

    <div>
        <button onclick="join(event)">JOIN</button>
        <button onclick="leave(event)">LEAVE</button>
    </div>
</body>

</html>
