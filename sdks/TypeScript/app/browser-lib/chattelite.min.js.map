{
  "version": 3,
  "sources": ["../src/generated/types.ts", "../src/generated/endpoints.ts", "../src/config.ts", "../src/utils.ts", "../src/index.ts", "../src/browser.ts"],
  "sourcesContent": ["// AUTOMATICALLY GENERATED, DO NOT EDIT!!\n// API input and output types\nexport type UserId = string\n\nexport type ConversationId = string;\n\nexport type user_id = string\n\nexport type DateTime = string\n    \n// API input types\n\n    \n// API output types\n\n\n\nexport type CreateUserInput = {\n    id: string,\n    display_name: string\n};\n\n\n\n\n\nexport type GenerateClientJwtInput = {\n    user_id: string\n};\n\nexport type GenerateClientJwtOutput = {\n    jwt: string\n};\n\n\n\nexport type CreateConversationInput = {\n    user_ids: UserId[]\n};\n\nexport type CreateConversationOutput = {\n    conversation_id: ConversationId\n};\n\n\n\nexport type AddUsersToConversationInput = {\n    user_ids: UserId[]\n};\n\n\n\nexport type RemoveUsersFromConversationInput = {\n    user_ids: UserId[]\n};\n\n\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\nimport * as T from \"@types\";\nimport * as utils from \"@utils\";\n\nexport type CreateUserResponse = utils.ApiResponse<{}, void>;\n\nexport function create_user (\n    opts: { session_token: string},\n    body: T.CreateUserInput\n): Promise<CreateUserResponse> {\n    return utils.post(`/users`, opts, body);\n}\n\nexport type DeleteUserResponse = utils.ApiResponse<{}, void>;\n\nexport function delete_user (\n    opts: { session_token: string},\n    user_id: String\n): Promise<DeleteUserResponse> {\n    return utils.del(`/user/${user_id}`, opts);\n}\n\nexport type GenerateClientJwtResponse = utils.ApiResponse<T.GenerateClientJwtOutput, void>;\n\nexport function generate_client_jwt (\n    opts: { session_token: string},\n    body: T.GenerateClientJwtInput\n): Promise<GenerateClientJwtResponse> {\n    return utils.post(`/gen-client-jwt`, opts, body);\n}\n\nexport type CreateConversationResponse = utils.ApiResponse<T.CreateConversationOutput, void>;\n\nexport function create_conversation (\n    opts: { session_token: string},\n    body: T.CreateConversationInput\n): Promise<CreateConversationResponse> {\n    return utils.post(`/conversations`, opts, body);\n}\n\nexport type AddUsersToConversationResponse = utils.ApiResponse<{}, void>;\n\nexport function add_users_to_conversation (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.AddUsersToConversationInput\n): Promise<AddUsersToConversationResponse> {\n    return utils.post(`/conversation/${conversation_id}/add-users`, opts, body);\n}\n\nexport type RemoveUsersFromConversationResponse = utils.ApiResponse<{}, void>;\n\nexport function remove_users_from_conversation (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.RemoveUsersFromConversationInput\n): Promise<RemoveUsersFromConversationResponse> {\n    return utils.post(`/conversation/${conversation_id}/remove-users`, opts, body);\n}\n", "export let API_URL: string | undefined = undefined;\n\nexport function init(api_url: string) {\n    API_URL = api_url;\n}\n", "import { API_URL } from \"./config\";\n\nexport type ApiResponse<S, E> = S | ApiResponseError<E>;\ntype BaseError = {\n    error: true;\n    status: number;\n    body: {\n        title: string;\n        detail: string;\n    };\n};\n\ntype NotFound = {\n    type: 'NotFound';\n    status: 404;\n};\n\ntype NotAuthenticated = {\n    type: 'NotAuthenticated';\n    status: 401;\n};\n\ntype Forbidden = {\n    type: 'Forbidden';\n    body: {\n        message: string;\n    };\n    status: 403;\n};\n\ntype BadRequest = {\n    type: 'BadRequest';\n    body: {\n        message: string;\n    };\n    status: 400;\n};\n\ntype InternalError = {\n    type: 'InternalError';\n    body: {\n        message: string;\n    };\n    status: 500;\n};\n\nexport type ApiResponseError<E> = BaseError &\n    (\n        | NotFound\n        | NotAuthenticated\n        | Forbidden\n        | BadRequest\n        | InternalError\n        | (E extends Object ? { body: E } : {})\n    );\n\nfunction maker_database_api_fetch(url: string, opts: any): Promise<ApiResponse<any, any>> {\n    let fetch_url = API_URL + url;\n    console.log(['fetch_url', fetch_url]);\n    const response = fetch(fetch_url, opts).then(async (res: Response) => {\n        console.log(res);\n\n        switch (res.status) {\n            case 200:\n                return res.json();\n            default:\n                return res.json().then((data) => {\n                    return {\n                        error: true,\n                        status: res.status,\n                        body: data\n                    };\n                });\n        }\n    });\n\n    return response;\n}\n\ntype ApiHeaders = {\n    Accept: string;\n    'Content-Type'?: string;\n    'X-Access-Token'?: string;\n};\n\nexport function get(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        headers\n    });\n}\n\nexport function post(url: string, opts: { session_token?: string }, body?: any) {\n    let b = body ? JSON.stringify(body) : 'null';\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        method: 'POST',\n        body: b,\n        headers\n    });\n}\n\nexport function del(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        method: 'DELETE',\n        headers\n    });\n}\n\nexport async function postFormData(\n    url: string,\n    opts: {\n        session_token: string;\n    },\n    formData: FormData\n) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n\n    return maker_database_api_fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers\n    });\n}\n\nfunction url_encode_add_key_value_pair(\n    result: [string, string][],\n    name: string,\n    value: string\n): void {\n    if (value === undefined || value === null) return;\n    result.push([encodeURIComponent(name), encodeURIComponent(value)]);\n}\n\ninterface QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n    url_encode(): [string, string][];\n}\n\nclass GenericQueryParams implements QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n\n    constructor(s: { [key: string]: string | number | boolean | QueryParamsInterface }) {\n        this.params = s;\n    }\n\n    url_encode(): [string, string][] {\n        let result: [string, string][] = [];\n        for (let key in this.params) {\n            let o = this.params[key];\n            if (o === null) continue;\n            if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {\n                url_encode_add_key_value_pair(result, key, o.toString());\n                continue;\n            }\n            if (Array.isArray(o)) {\n                if (o.length > 0) {\n                    if (\n                        typeof o[0] === 'string' ||\n                        typeof o[0] === 'number' ||\n                        typeof o[0] === 'boolean'\n                    ) {\n                        url_encode_add_key_value_pair(result, key, o.join(','));\n                        continue;\n                    }\n                    /*if (typeof o[0] === \"object\" && o[0].hasOwnProperty(\"url_encode\")) {\n                        continue;\n                    }*/\n                }\n                throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n            }\n            if (typeof o === 'object' && o.hasOwnProperty('url_encode')) {\n                for (let [k, v] of o.url_encode()) {\n                    result.push([`${key}.${k}`, v]);\n                }\n            }\n            throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n        }\n\n        return result;\n    }\n}\n\nexport function stringify_query(q: any): string {\n    let result = new GenericQueryParams(q).url_encode();\n    console.log(['stringify_query', result]);\n    return result.length > 0 ? `?${result.map(([k, v]) => `${k}=${v}`).join('&')}` : '';\n}\n\nexport default {\n    get: get,\n    post: post,\n    postFormData: postFormData\n};\n", "import * as Types from \"./generated/types\";\nimport * as Endpoints from \"./generated/endpoints\";\nimport { init } from \"./config\";\n\nconst Chattelite = {\n    Types,\n    Endpoints,\n    init,\n};\n\nexport default Chattelite;\n", "import Chattelite from \".\";\n\n//@ts-ignore\nwindow[\"Chattelite\"] = Chattelite;\n"],
  "mappings": "0TAAA,IAAAA,EAAA,GCAA,IAAAC,EAAA,GAAAC,EAAAD,EAAA,+BAAAE,EAAA,wBAAAC,EAAA,gBAAAC,EAAA,gBAAAC,EAAA,wBAAAC,EAAA,mCAAAC,ICAO,IAAIC,EAEJ,SAASC,EAAKC,EAAiB,CAClCF,EAAUE,CACd,CCoDA,SAASC,EAAyBC,EAAaC,EAA2C,CACtF,IAAIC,EAAYC,EAAUH,EAC1B,eAAQ,IAAI,CAAC,YAAaE,CAAS,CAAC,EACnB,MAAMA,EAAWD,CAAI,EAAE,KAAYG,GAAkBC,EAAA,sBAGlE,OAFA,QAAQ,IAAID,CAAG,EAEPA,EAAI,OAAQ,CAChB,IAAK,KACD,OAAOA,EAAI,KAAK,EACpB,QACI,OAAOA,EAAI,KAAK,EAAE,KAAME,IACb,CACH,MAAO,GACP,OAAQF,EAAI,OACZ,KAAME,CACV,EACH,CACT,CACJ,EAAC,CAGL,CAqBO,SAASC,EAAKC,EAAaC,EAAkCC,EAAY,CAC5E,IAAIC,EAAID,EAAO,KAAK,UAAUA,CAAI,EAAI,OAClCE,EAAsB,CACtB,OAAQ,mBACR,eAAgB,kBACpB,EACA,OAAIH,EAAK,gBACLG,EAAQ,kBAAoBH,EAAK,eAE9BI,EAAyBL,EAAK,CACjC,OAAQ,OACR,KAAMG,EACN,QAAAC,CACJ,CAAC,CACL,CAEO,SAASE,EAAIN,EAAaC,EAAkC,CAC/D,IAAIG,EAAsB,CACtB,OAAQ,mBACR,eAAgB,kBACpB,EACA,OAAIH,EAAK,gBACLG,EAAQ,kBAAoBH,EAAK,eAE9BI,EAAyBL,EAAK,CACjC,OAAQ,SACR,QAAAI,CACJ,CAAC,CACL,CFxHO,SAASG,EACZC,EACAC,EAC2B,CAC3B,OAAaC,EAAK,SAAUF,EAAMC,CAAI,CAC1C,CAIO,SAASE,EACZH,EACAI,EAC2B,CAC3B,OAAaC,EAAI,SAASD,IAAWJ,CAAI,CAC7C,CAIO,SAASM,EACZN,EACAC,EACkC,CAClC,OAAaC,EAAK,kBAAmBF,EAAMC,CAAI,CACnD,CAIO,SAASM,EACZP,EACAC,EACmC,CACnC,OAAaC,EAAK,iBAAkBF,EAAMC,CAAI,CAClD,CAIO,SAASO,EACZR,EACAS,EACAR,EACuC,CACvC,OAAaC,EAAK,iBAAiBO,cAA6BT,EAAMC,CAAI,CAC9E,CAIO,SAASS,EACZV,EACAS,EACAR,EAC4C,CAC5C,OAAaC,EAAK,iBAAiBO,iBAAgCT,EAAMC,CAAI,CACjF,CGtDA,IAAMU,EAAa,CACf,MAAAC,EACA,UAAAC,EACA,KAAAC,CACJ,EAEOC,EAAQJ,ECPf,OAAO,WAAgBK",
  "names": ["types_exports", "endpoints_exports", "__export", "add_users_to_conversation", "create_conversation", "create_user", "delete_user", "generate_client_jwt", "remove_users_from_conversation", "API_URL", "init", "api_url", "maker_database_api_fetch", "url", "opts", "fetch_url", "API_URL", "res", "__async", "data", "post", "url", "opts", "body", "b", "headers", "maker_database_api_fetch", "del", "create_user", "opts", "body", "post", "delete_user", "user_id", "del", "generate_client_jwt", "create_conversation", "add_users_to_conversation", "conversation_id", "remove_users_from_conversation", "Chattelite", "types_exports", "endpoints_exports", "init", "src_default", "src_default"]
}
