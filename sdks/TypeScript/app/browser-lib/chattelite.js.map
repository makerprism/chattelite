{
  "version": 3,
  "sources": ["../src/generated/types.ts", "../src/generated/endpoints.ts", "../src/config.ts", "../src/utils.ts", "../src/index.ts", "../src/browser.ts"],
  "sourcesContent": ["// AUTOMATICALLY GENERATED, DO NOT EDIT!!\n// API input and output types\nexport type UserId = string\n\nexport type ConversationId = string;\n\nexport type user_id = string\n\nexport type DateTime = string\n    \n// API input types\n\n    \n// API output types\n\n\n\nexport type CreateUserInput = {\n    id: string,\n    display_name: string\n};\n\n\n\n\n\nexport type GenerateClientJwtInput = {\n    user_id: string\n};\n\nexport type GenerateClientJwtOutput = {\n    jwt: string\n};\n\n\n\nexport type CreateConversationInput = {\n    user_ids: UserId[]\n};\n\nexport type CreateConversationOutput = {\n    conversation_id: ConversationId\n};\n\n\n\nexport type AddUsersToConversationInput = {\n    user_ids: UserId[]\n};\n\n\n\nexport type RemoveUsersFromConversationInput = {\n    user_ids: UserId[]\n};\n\n\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\nimport * as T from \"@types\";\nimport * as utils from \"@utils\";\n\nexport type CreateUserResponse = utils.ApiResponse<{}, void>;\n\nexport function create_user (\n    opts: { session_token: string},\n    body: T.CreateUserInput\n): Promise<CreateUserResponse> {\n    return utils.post(`/users`, opts, body);\n}\n\nexport type DeleteUserResponse = utils.ApiResponse<{}, void>;\n\nexport function delete_user (\n    opts: { session_token: string},\n    user_id: String\n): Promise<DeleteUserResponse> {\n    return utils.del(`/user/${user_id}`, opts);\n}\n\nexport type GenerateClientJwtResponse = utils.ApiResponse<T.GenerateClientJwtOutput, void>;\n\nexport function generate_client_jwt (\n    opts: { session_token: string},\n    body: T.GenerateClientJwtInput\n): Promise<GenerateClientJwtResponse> {\n    return utils.post(`/gen-client-jwt`, opts, body);\n}\n\nexport type CreateConversationResponse = utils.ApiResponse<T.CreateConversationOutput, void>;\n\nexport function create_conversation (\n    opts: { session_token: string},\n    body: T.CreateConversationInput\n): Promise<CreateConversationResponse> {\n    return utils.post(`/conversations`, opts, body);\n}\n\nexport type AddUsersToConversationResponse = utils.ApiResponse<{}, void>;\n\nexport function add_users_to_conversation (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.AddUsersToConversationInput\n): Promise<AddUsersToConversationResponse> {\n    return utils.post(`/conversation/${conversation_id}/add-users`, opts, body);\n}\n\nexport type RemoveUsersFromConversationResponse = utils.ApiResponse<{}, void>;\n\nexport function remove_users_from_conversation (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.RemoveUsersFromConversationInput\n): Promise<RemoveUsersFromConversationResponse> {\n    return utils.post(`/conversation/${conversation_id}/remove-users`, opts, body);\n}\n", "export let API_URL: string | undefined = undefined;\n\nexport function init(api_url: string) {\n    API_URL = api_url;\n}\n", "import { API_URL } from \"./config\";\n\nexport type ApiResponse<S, E> = S | ApiResponseError<E>;\ntype BaseError = {\n    error: true;\n    status: number;\n    body: {\n        title: string;\n        detail: string;\n    };\n};\n\ntype NotFound = {\n    type: 'NotFound';\n    status: 404;\n};\n\ntype NotAuthenticated = {\n    type: 'NotAuthenticated';\n    status: 401;\n};\n\ntype Forbidden = {\n    type: 'Forbidden';\n    body: {\n        message: string;\n    };\n    status: 403;\n};\n\ntype BadRequest = {\n    type: 'BadRequest';\n    body: {\n        message: string;\n    };\n    status: 400;\n};\n\ntype InternalError = {\n    type: 'InternalError';\n    body: {\n        message: string;\n    };\n    status: 500;\n};\n\nexport type ApiResponseError<E> = BaseError &\n    (\n        | NotFound\n        | NotAuthenticated\n        | Forbidden\n        | BadRequest\n        | InternalError\n        | (E extends Object ? { body: E } : {})\n    );\n\nfunction maker_database_api_fetch(url: string, opts: any): Promise<ApiResponse<any, any>> {\n    let fetch_url = API_URL + url;\n    console.log(['fetch_url', fetch_url]);\n    const response = fetch(fetch_url, opts).then(async (res: Response) => {\n        console.log(res);\n\n        switch (res.status) {\n            case 200:\n                return res.json();\n            default:\n                return res.json().then((data) => {\n                    return {\n                        error: true,\n                        status: res.status,\n                        body: data\n                    };\n                });\n        }\n    });\n\n    return response;\n}\n\ntype ApiHeaders = {\n    Accept: string;\n    'Content-Type'?: string;\n    'X-Access-Token'?: string;\n};\n\nexport function get(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        headers\n    });\n}\n\nexport function post(url: string, opts: { session_token?: string }, body?: any) {\n    let b = body ? JSON.stringify(body) : 'null';\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        method: 'POST',\n        body: b,\n        headers\n    });\n}\n\nexport function del(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return maker_database_api_fetch(url, {\n        method: 'DELETE',\n        headers\n    });\n}\n\nexport async function postFormData(\n    url: string,\n    opts: {\n        session_token: string;\n    },\n    formData: FormData\n) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n\n    return maker_database_api_fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers\n    });\n}\n\nfunction url_encode_add_key_value_pair(\n    result: [string, string][],\n    name: string,\n    value: string\n): void {\n    if (value === undefined || value === null) return;\n    result.push([encodeURIComponent(name), encodeURIComponent(value)]);\n}\n\ninterface QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n    url_encode(): [string, string][];\n}\n\nclass GenericQueryParams implements QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n\n    constructor(s: { [key: string]: string | number | boolean | QueryParamsInterface }) {\n        this.params = s;\n    }\n\n    url_encode(): [string, string][] {\n        let result: [string, string][] = [];\n        for (let key in this.params) {\n            let o = this.params[key];\n            if (o === null) continue;\n            if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {\n                url_encode_add_key_value_pair(result, key, o.toString());\n                continue;\n            }\n            if (Array.isArray(o)) {\n                if (o.length > 0) {\n                    if (\n                        typeof o[0] === 'string' ||\n                        typeof o[0] === 'number' ||\n                        typeof o[0] === 'boolean'\n                    ) {\n                        url_encode_add_key_value_pair(result, key, o.join(','));\n                        continue;\n                    }\n                    /*if (typeof o[0] === \"object\" && o[0].hasOwnProperty(\"url_encode\")) {\n                        continue;\n                    }*/\n                }\n                throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n            }\n            if (typeof o === 'object' && o.hasOwnProperty('url_encode')) {\n                for (let [k, v] of o.url_encode()) {\n                    result.push([`${key}.${k}`, v]);\n                }\n            }\n            throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n        }\n\n        return result;\n    }\n}\n\nexport function stringify_query(q: any): string {\n    let result = new GenericQueryParams(q).url_encode();\n    console.log(['stringify_query', result]);\n    return result.length > 0 ? `?${result.map(([k, v]) => `${k}=${v}`).join('&')}` : '';\n}\n\nexport default {\n    get: get,\n    post: post,\n    postFormData: postFormData\n};\n", "import * as Types from \"./generated/types\";\nimport * as Endpoints from \"./generated/endpoints\";\nimport { init } from \"./config\";\n\nconst Chattelite = {\n    Types,\n    Endpoints,\n    init,\n};\n\nexport default Chattelite;\n", "import Chattelite from \".\";\n\n//@ts-ignore\nwindow[\"Chattelite\"] = Chattelite;\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,MAAI,UAA8B;AAElC,WAAS,KAAK,SAAiB;AAClC,cAAU;AAAA,EACd;;;ACoDA,WAAS,yBAAyB,KAAa,MAA2C;AACtF,QAAI,YAAY,UAAU;AAC1B,YAAQ,IAAI,CAAC,aAAa,SAAS,CAAC;AACpC,UAAM,WAAW,MAAM,WAAW,IAAI,EAAE,KAAK,CAAO,QAAkB;AAClE,cAAQ,IAAI,GAAG;AAEf,cAAQ,IAAI,QAAQ;AAAA,QAChB,KAAK;AACD,iBAAO,IAAI,KAAK;AAAA,QACpB;AACI,iBAAO,IAAI,KAAK,EAAE,KAAK,CAAC,SAAS;AAC7B,mBAAO;AAAA,cACH,OAAO;AAAA,cACP,QAAQ,IAAI;AAAA,cACZ,MAAM;AAAA,YACV;AAAA,UACJ,CAAC;AAAA,MACT;AAAA,IACJ,EAAC;AAED,WAAO;AAAA,EACX;AAqBO,WAAS,KAAK,KAAa,MAAkC,MAAY;AAC5E,QAAI,IAAI,OAAO,KAAK,UAAU,IAAI,IAAI;AACtC,QAAI,UAAsB;AAAA,MACtB,QAAQ;AAAA,MACR,gBAAgB;AAAA,IACpB;AACA,QAAI,KAAK,eAAe;AACpB,cAAQ,oBAAoB,KAAK;AAAA,IACrC;AACA,WAAO,yBAAyB,KAAK;AAAA,MACjC,QAAQ;AAAA,MACR,MAAM;AAAA,MACN;AAAA,IACJ,CAAC;AAAA,EACL;AAEO,WAAS,IAAI,KAAa,MAAkC;AAC/D,QAAI,UAAsB;AAAA,MACtB,QAAQ;AAAA,MACR,gBAAgB;AAAA,IACpB;AACA,QAAI,KAAK,eAAe;AACpB,cAAQ,oBAAoB,KAAK;AAAA,IACrC;AACA,WAAO,yBAAyB,KAAK;AAAA,MACjC,QAAQ;AAAA,MACR;AAAA,IACJ,CAAC;AAAA,EACL;;;AFxHO,WAAS,YACZ,MACA,MAC2B;AAC3B,WAAa,KAAK,UAAU,MAAM,IAAI;AAAA,EAC1C;AAIO,WAAS,YACZ,MACA,SAC2B;AAC3B,WAAa,IAAI,SAAS,WAAW,IAAI;AAAA,EAC7C;AAIO,WAAS,oBACZ,MACA,MACkC;AAClC,WAAa,KAAK,mBAAmB,MAAM,IAAI;AAAA,EACnD;AAIO,WAAS,oBACZ,MACA,MACmC;AACnC,WAAa,KAAK,kBAAkB,MAAM,IAAI;AAAA,EAClD;AAIO,WAAS,0BACZ,MACA,iBACA,MACuC;AACvC,WAAa,KAAK,iBAAiB,6BAA6B,MAAM,IAAI;AAAA,EAC9E;AAIO,WAAS,+BACZ,MACA,iBACA,MAC4C;AAC5C,WAAa,KAAK,iBAAiB,gCAAgC,MAAM,IAAI;AAAA,EACjF;;;AGtDA,MAAM,aAAa;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAEA,MAAO,cAAQ;;;ACPf,SAAO,gBAAgB;",
  "names": []
}
