{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/config.ts", "../src/generated/types.ts", "../src/generated/endpoints.ts", "../src/index.ts", "../src/browser.ts"],
  "sourcesContent": ["import { API_URL } from \"./config\";\n\nexport type ApiResponse<S, E> = S | ApiResponseError<E>;\ntype BaseError = {\n    error: true;\n    status: number;\n    body: {\n        title: string;\n        detail: string;\n    };\n};\n\ntype NotFound = {\n    type: 'NotFound';\n    status: 404;\n};\n\ntype NotAuthenticated = {\n    type: 'NotAuthenticated';\n    status: 401;\n};\n\ntype Forbidden = {\n    type: 'Forbidden';\n    body: {\n        message: string;\n    };\n    status: 403;\n};\n\ntype BadRequest = {\n    type: 'BadRequest';\n    body: {\n        message: string;\n    };\n    status: 400;\n};\n\ntype InternalError = {\n    type: 'InternalError';\n    body: {\n        message: string;\n    };\n    status: 500;\n};\n\nexport type ApiResponseError<E> = BaseError &\n    (\n        | NotFound\n        | NotAuthenticated\n        | Forbidden\n        | BadRequest\n        | InternalError\n        | (E extends Object ? { body: E } : {})\n    );\n\nfunction api_fetch(url: string, opts: any): Promise<ApiResponse<any, any>> {\n    let fetch_url = API_URL + url;\n    console.log(['fetch_url', fetch_url]);\n    const response = fetch(fetch_url, opts).then(async (res: Response) => {\n        console.log(res);\n\n        switch (res.status) {\n            case 200:\n                return res.json();\n            default:\n                return res.json().then((data) => {\n                    return {\n                        error: true,\n                        status: res.status,\n                        body: data\n                    };\n                });\n        }\n    });\n\n    return response;\n}\n\ntype ApiHeaders = {\n    Accept: string;\n    'Content-Type'?: string;\n    'X-Access-Token'?: string;\n};\n\nexport function get(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        headers\n    });\n}\n\nexport function post(url: string, opts: { session_token?: string }, body?: any) {\n    let b = body ? JSON.stringify(body) : 'null';\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        method: 'POST',\n        body: b,\n        headers\n    });\n}\n\nexport function del(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        method: 'DELETE',\n        headers\n    });\n}\n\nexport async function postFormData(\n    url: string,\n    opts: {\n        session_token: string;\n    },\n    formData: FormData\n) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n\n    return api_fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers\n    });\n}\n\nfunction url_encode_add_key_value_pair(\n    result: [string, string][],\n    name: string,\n    value: string\n): void {\n    if (value === undefined || value === null) return;\n    result.push([encodeURIComponent(name), encodeURIComponent(value)]);\n}\n\ninterface QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n    url_encode(): [string, string][];\n}\n\nclass GenericQueryParams implements QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n\n    constructor(s: { [key: string]: string | number | boolean | QueryParamsInterface }) {\n        this.params = s;\n    }\n\n    url_encode(): [string, string][] {\n        let result: [string, string][] = [];\n        for (let key in this.params) {\n            let o = this.params[key];\n            if (o === null) continue;\n            if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {\n                url_encode_add_key_value_pair(result, key, o.toString());\n                continue;\n            }\n            if (Array.isArray(o)) {\n                if (o.length > 0) {\n                    if (\n                        typeof o[0] === 'string' ||\n                        typeof o[0] === 'number' ||\n                        typeof o[0] === 'boolean'\n                    ) {\n                        url_encode_add_key_value_pair(result, key, o.join(','));\n                        continue;\n                    }\n                    /*if (typeof o[0] === \"object\" && o[0].hasOwnProperty(\"url_encode\")) {\n                        continue;\n                    }*/\n                }\n                throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n            }\n            if (typeof o === 'object' && o.hasOwnProperty('url_encode')) {\n                for (let [k, v] of o.url_encode()) {\n                    result.push([`${key}.${k}`, v]);\n                }\n            }\n            throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n        }\n\n        return result;\n    }\n}\n\nexport function stringify_query(q: any): string {\n    let result = new GenericQueryParams(q).url_encode();\n    console.log(['stringify_query', result]);\n    return result.length > 0 ? `?${result.map(([k, v]) => `${k}=${v}`).join('&')}` : '';\n}\n\nexport default {\n    get: get,\n    post: post,\n    postFormData: postFormData\n};\n", "export let API_URL: string | undefined = undefined;\n\nexport function init(api_url: string) {\n    API_URL = api_url;\n}\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\n// API input and output types\nexport type UserId = string\n\nexport type ConversationId = string;\n\nexport type LineId = string;\n\nexport type user_id = string\n\nexport type DateTime = string\n    \n// API input types\n\n    \n// API output types\nexport type User = {\n    id: UserId,\n    display_name: string\n}\n\nexport type ConnectionEvent = ConnectionEventUnreadMessage\n\nexport type ConnectionEventUnreadMessage = {\n    type: \"UnreadMessage\",\n    timestamp: DateTime,\n    conversation_id: ConversationId,\n    from: User\n}\n\nexport type ConversationEvent = ConversationEventMessage | ConversationEventJoin | ConversationEventLeave | ConversationEventStartTyping | ConversationEventEndTyping\n\nexport type ConversationEventMessage = {\n    type: \"Message\",\n    timestamp: DateTime,\n    from: User,\n    content: string\n}\n\nexport type ConversationEventJoin = {\n    type: \"Join\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventLeave = {\n    type: \"Leave\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventStartTyping = {\n    type: \"StartTyping\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventEndTyping = {\n    type: \"EndTyping\",\n    timestamp: DateTime,\n    from: User\n}\n\n\nexport type GetConnectionEventsOutput = {\n    events: ConnectionEvent[]\n};\n\n\n\nexport type GetConversationEventsOutput = {\n    events: ConversationEvent[]\n};\n\n\n\nexport type SendMessageInput = {\n    content: string\n};\n\n\n\n\n\n\n\nexport type MarkReadInput = {\n    conversation_id: ConversationId,\n    line_id: LineId\n};\n\n\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\nimport * as T from \"@types\";\nimport * as utils from \"@utils\";\n\nexport type GetConnectionEventsResponse = utils.ApiResponse<T.GetConnectionEventsOutput, void>;\n\nexport function get_connection_events (\n    opts: { session_token: string}\n): Promise<GetConnectionEventsResponse> {\n    return utils.get(`/events`, opts);\n}\n\nexport type GetConversationEventsResponse = utils.ApiResponse<T.GetConversationEventsOutput, void>;\n\nexport function get_conversation_events (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId\n): Promise<GetConversationEventsResponse> {\n    return utils.get(`/conversation/${conversation_id}/events`, opts);\n}\n\nexport type SendMessageResponse = utils.ApiResponse<{}, void>;\n\nexport function send_message (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.SendMessageInput\n): Promise<SendMessageResponse> {\n    return utils.post(`/conversation/${conversation_id}`, opts, body);\n}\n\nexport type StartTypingResponse = utils.ApiResponse<{}, void>;\n\nexport function start_typing (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: {}\n): Promise<StartTypingResponse> {\n    return utils.post(`/conversation/${conversation_id}/start-typing`, opts, body);\n}\n\nexport type StopTypingResponse = utils.ApiResponse<{}, void>;\n\nexport function stop_typing (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: {}\n): Promise<StopTypingResponse> {\n    return utils.post(`/conversation/${conversation_id}/stop-typing`, opts, body);\n}\n\nexport type MarkReadResponse = utils.ApiResponse<{}, void>;\n\nexport function mark_read (\n    opts: { session_token: string},\n    body: T.MarkReadInput\n): Promise<MarkReadResponse> {\n    return utils.post(`/read`, opts, body);\n}\n", "//import * as EventSourceWithHeaders from \"event-source-with-headers\";\n\nimport * as Utils from \"./utils\";\nimport * as Types from \"./generated/types\";\nimport * as Endpoints from \"./generated/endpoints\";\nimport { init } from \"./config\";\n\n\nconst ChatteliteClient = {\n    //EventSourceWithHeaders,\n    init,\n    Types,\n    Endpoints,\n    Utils,\n}\n\nexport default ChatteliteClient;\n", "import ChatteliteClient from \".\";\n\n//@ts-ignore\nwindow[\"ChatteliteClient\"] = ChatteliteClient;\n"],
  "mappings": "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",
  "names": []
}
