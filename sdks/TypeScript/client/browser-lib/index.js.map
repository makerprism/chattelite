{
  "version": 3,
  "sources": ["../src/utils.ts", "../src/config.ts", "../src/generated/types.ts", "../src/generated/endpoints.ts", "../src/index.ts", "../src/browser.ts"],
  "sourcesContent": ["import { API_URL } from \"./config\";\n\nexport type ApiResponse<S, E> = S | ApiResponseError<E>;\ntype BaseError = {\n    error: true;\n    status: number;\n    body: {\n        title: string;\n        detail: string;\n    };\n};\n\ntype NotFound = {\n    type: 'NotFound';\n    status: 404;\n};\n\ntype NotAuthenticated = {\n    type: 'NotAuthenticated';\n    status: 401;\n};\n\ntype Forbidden = {\n    type: 'Forbidden';\n    body: {\n        message: string;\n    };\n    status: 403;\n};\n\ntype BadRequest = {\n    type: 'BadRequest';\n    body: {\n        message: string;\n    };\n    status: 400;\n};\n\ntype InternalError = {\n    type: 'InternalError';\n    body: {\n        message: string;\n    };\n    status: 500;\n};\n\nexport type ApiResponseError<E> = BaseError &\n    (\n        | NotFound\n        | NotAuthenticated\n        | Forbidden\n        | BadRequest\n        | InternalError\n        | (E extends Object ? { body: E } : {})\n    );\n\nfunction api_fetch(url: string, opts: any): Promise<ApiResponse<any, any>> {\n    let fetch_url = API_URL + url;\n    console.log(['fetch_url', fetch_url]);\n    const response = fetch(fetch_url, opts).then(async (res: Response) => {\n        console.log(res);\n\n        switch (res.status) {\n            case 200:\n                return res.json();\n            default:\n                return res.json().then((data) => {\n                    return {\n                        error: true,\n                        status: res.status,\n                        body: data\n                    };\n                });\n        }\n    });\n\n    return response;\n}\n\ntype ApiHeaders = {\n    Accept: string;\n    'Content-Type'?: string;\n    'X-Access-Token'?: string;\n};\n\nexport function get(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        headers\n    });\n}\n\nexport function post(url: string, opts: { session_token?: string }, body?: any) {\n    let b = body ? JSON.stringify(body) : 'null';\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        method: 'POST',\n        body: b,\n        headers\n    });\n}\n\nexport function del(url: string, opts: { session_token?: string }) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n    return api_fetch(url, {\n        method: 'DELETE',\n        headers\n    });\n}\n\nexport async function postFormData(\n    url: string,\n    opts: {\n        session_token: string;\n    },\n    formData: FormData\n) {\n    let headers: ApiHeaders = {\n        Accept: 'application/json'\n    };\n    if (opts.session_token) {\n        headers['X-Access-Token'] = opts.session_token;\n    }\n\n    return api_fetch(url, {\n        method: 'POST',\n        body: formData,\n        headers\n    });\n}\n\nfunction url_encode_add_key_value_pair(\n    result: [string, string][],\n    name: string,\n    value: string\n): void {\n    if (value === undefined || value === null) return;\n    result.push([encodeURIComponent(name), encodeURIComponent(value)]);\n}\n\ninterface QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n    url_encode(): [string, string][];\n}\n\nclass GenericQueryParams implements QueryParamsInterface {\n    params: { [key: string]: string | number | boolean | QueryParamsInterface };\n\n    constructor(s: { [key: string]: string | number | boolean | QueryParamsInterface }) {\n        this.params = s;\n    }\n\n    url_encode(): [string, string][] {\n        let result: [string, string][] = [];\n        for (let key in this.params) {\n            let o = this.params[key];\n            if (o === null) continue;\n            if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {\n                url_encode_add_key_value_pair(result, key, o.toString());\n                continue;\n            }\n            if (Array.isArray(o)) {\n                if (o.length > 0) {\n                    if (\n                        typeof o[0] === 'string' ||\n                        typeof o[0] === 'number' ||\n                        typeof o[0] === 'boolean'\n                    ) {\n                        url_encode_add_key_value_pair(result, key, o.join(','));\n                        continue;\n                    }\n                    /*if (typeof o[0] === \"object\" && o[0].hasOwnProperty(\"url_encode\")) {\n                        continue;\n                    }*/\n                }\n                throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n            }\n            if (typeof o === 'object' && o.hasOwnProperty('url_encode')) {\n                for (let [k, v] of o.url_encode()) {\n                    result.push([`${key}.${k}`, v]);\n                }\n            }\n            throw 'url_encode not implemented for ' + typeof o + ' ' + JSON.stringify(o);\n        }\n\n        return result;\n    }\n}\n\nexport function stringify_query(q: any): string {\n    let result = new GenericQueryParams(q).url_encode();\n    console.log(['stringify_query', result]);\n    return result.length > 0 ? `?${result.map(([k, v]) => `${k}=${v}`).join('&')}` : '';\n}\n\nexport default {\n    get: get,\n    post: post,\n    postFormData: postFormData\n};\n", "export let API_URL: string | undefined = undefined;\n\nexport function init(api_url: string) {\n    API_URL = api_url;\n}\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\n// API input and output types\nexport type UserId = string\n\nexport type ConversationId = string;\n\nexport type LineId = string;\n\nexport type user_id = string\n\nexport type DateTime = string\n    \n// API input types\n\n    \n// API output types\nexport type User = {\n    id: UserId,\n    display_name: string\n}\n\nexport type ConnectionEvent = ConnectionEventUnreadMessage\n\nexport type ConnectionEventUnreadMessage = {\n    type: \"UnreadMessage\",\n    timestamp: DateTime,\n    conversation_id: ConversationId,\n    from: User\n}\n\nexport type ConversationEvent = ConversationEventMessage | ConversationEventJoin | ConversationEventLeave | ConversationEventStartTyping | ConversationEventEndTyping\n\nexport type ConversationEventMessage = {\n    type: \"Message\",\n    timestamp: DateTime,\n    from: User,\n    content: string\n}\n\nexport type ConversationEventJoin = {\n    type: \"Join\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventLeave = {\n    type: \"Leave\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventStartTyping = {\n    type: \"StartTyping\",\n    timestamp: DateTime,\n    from: User\n}\n\nexport type ConversationEventEndTyping = {\n    type: \"EndTyping\",\n    timestamp: DateTime,\n    from: User\n}\n\n\nexport type GetConnectionEventsOutput = {\n    events: ConnectionEvent[]\n};\n\n\n\nexport type GetConversationEventsOutput = {\n    events: ConversationEvent[]\n};\n\n\n\nexport type SendMessageInput = {\n    content: string\n};\n\n\n\n\n\n\n\nexport type MarkReadInput = {\n    conversation_id: ConversationId,\n    line_id: LineId\n};\n\n\n", "// AUTOMATICALLY GENERATED, DO NOT EDIT!!\nimport * as T from \"@types\";\nimport * as utils from \"@utils\";\n\nexport type GetConnectionEventsResponse = utils.ApiResponse<T.GetConnectionEventsOutput, void>;\n\nexport function get_connection_events (\n    opts: { session_token: string}\n): Promise<GetConnectionEventsResponse> {\n    return utils.get(`/events`, opts);\n}\n\nexport type GetConversationEventsResponse = utils.ApiResponse<T.GetConversationEventsOutput, void>;\n\nexport function get_conversation_events (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId\n): Promise<GetConversationEventsResponse> {\n    return utils.get(`/conversation/${conversation_id}/events`, opts);\n}\n\nexport type SendMessageResponse = utils.ApiResponse<{}, void>;\n\nexport function send_message (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: T.SendMessageInput\n): Promise<SendMessageResponse> {\n    return utils.post(`/conversation/${conversation_id}`, opts, body);\n}\n\nexport type StartTypingResponse = utils.ApiResponse<{}, void>;\n\nexport function start_typing (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: {}\n): Promise<StartTypingResponse> {\n    return utils.post(`/conversation/${conversation_id}/start-typing`, opts, body);\n}\n\nexport type StopTypingResponse = utils.ApiResponse<{}, void>;\n\nexport function stop_typing (\n    opts: { session_token: string},\n    conversation_id: T.ConversationId,\n    body: {}\n): Promise<StopTypingResponse> {\n    return utils.post(`/conversation/${conversation_id}/stop-typing`, opts, body);\n}\n\nexport type MarkReadResponse = utils.ApiResponse<{}, void>;\n\nexport function mark_read (\n    opts: { session_token: string},\n    body: T.MarkReadInput\n): Promise<MarkReadResponse> {\n    return utils.post(`/read`, opts, body);\n}\n", "//import * as EventSourceWithHeaders from \"event-source-with-headers\";\n\nimport * as Utils from \"./utils\";\nimport * as Types from \"./generated/types\";\nimport * as Endpoints from \"./generated/endpoints\";\nimport { init } from \"./config\";\n\n\nconst ChatteliteClient = {\n    //EventSourceWithHeaders,\n    init,\n    Types,\n    Endpoints,\n    Utils,\n}\n\nexport default ChatteliteClient;\n", "import ChatteliteClient from \".\";\n\n//@ts-ignore\nwindow[\"ChatteliteClient\"] = ChatteliteClient;\n"],
  "mappings": "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",
  "names": ["utils_exports", "__export", "utils_default", "del", "get", "post", "postFormData", "stringify_query", "API_URL", "init", "api_url", "api_fetch", "url", "opts", "fetch_url", "API_URL", "res", "__async", "data", "get", "headers", "post", "body", "b", "del", "postFormData", "formData", "url_encode_add_key_value_pair", "result", "name", "value", "GenericQueryParams", "s", "key", "o", "k", "v", "stringify_query", "q", "utils_default", "types_exports", "endpoints_exports", "__export", "get_connection_events", "get_conversation_events", "mark_read", "send_message", "start_typing", "stop_typing", "get_connection_events", "opts", "get", "get_conversation_events", "conversation_id", "send_message", "body", "post", "start_typing", "stop_typing", "mark_read", "ChatteliteClient", "init", "types_exports", "endpoints_exports", "utils_exports", "src_default", "src_default"]
}
